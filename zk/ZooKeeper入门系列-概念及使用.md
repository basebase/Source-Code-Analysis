### ZooKeeper入门系列之概念及使用.md

#### 说在前面
本文主要从以下几个方面介绍ZooKeeper。
  * ZooKeeper能做什么
  * ZooKeeper一些术语
  * ZooKeeper的架构图
  * ZooKeeper的命令使用




#### ZooKeeper能做什么?
ZooKeeper为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。

例如:
  * 名称服务
    + 将一个名称映射到与该名称有关联的一些信息的服务。电话目录是将人的名字映射到其电话号码的一个名称服务。同样DNS服务也是一个名称服务, 他将一个域名映射到一个IP地址。在分布式系统中, 可能想要跟踪那些服务器或者服务在运行, 并通过名称查看状态。ZK暴露一个简单的接口来完成此工作。当然也可以将名称服务扩展到组成员服务, 这样就可以获得与正在查找其名称的实体有关联的组的信息。

  * 锁
    + 为了允许在分布式系统中对共享资源进行有序的访问, 可能需要实现分布式互斥, ZK提供一种简单的方式来实现

  * 配置管理
    + 可以使用ZK集中存储和管理分布式系统的配置。这意味着, 所有新加入的节点都将在加入系统后就可以立即使用来自ZK的最新的配置。还可以通过其中一个ZK客户端更改配置, 更改分布式系统状态。

  * 选举
    + 当分布式系统主节点服务停机了, 想要实现故障转移, 可以通过ZK进行选举。



#### ZooKeeper术语
ZooKeeper有以下几个概念, 我们先来看看有哪些个把。
  * 集群角色
  * 会话
  * 数据节点
  * 版本
  * 事件监听器
  * ACL
  * 名称服务
  * Locking
  * 同步
  * 配置管理
  * Leader选举


1. 集群角色
 + 集群系统都有自己的角色, 常规的比如master/Slave(主从模式), 但是ZK并不是这种模式而是引入了Leader, Follower和Observer三种角色, ZK集群通过一个Leader选举过程来选定一台被称为"Leader"的机器。Leader服务器为客户端提供读写服务。除了Leader外其它机器包括Follower和Observer都能提供读服务, 唯一的区别在于Observer机器不参与Leader选举过程, 也不参与写操作的"过半写成功"策略。因此Observer可以在不影响写性能下提升集群读性能。

 + Leader: 领导者负责进行投票的发起和决议, 更新系统状态
 + Follower: 用于接收客户端请求并行客户端返回结果, 在选主过程中参与投票
 + Observer: 可以接收客户端连接, 将写请求转发给Leader节点, 但Observer不参加投票过程, 只同步Leader的状态, Observer的目的是为了扩展系统, 提高读取速度。
 + Client: 请求发起方


2. 会话(Session)
  + 会话指的ZK客户端和ZK服务器连接, 客户端与服务器建立一个TCP长连接来维持一个会话, 客户端在启动的时候首先会与服务器建立一个TCP连接, 通过这个连接, 客户端能够通过心跳检测与服务器保持有效的会话。

  + ZK对外端口号是2181
  + Session的SessionTimeout来设置一个客户端会话超时时间, 当由于服务器压力大、网络故障或者是客户端主动断开连接等各种原因导致客户端断开连接时, 只要在SessionTimeOut规定的时间内能够重新连接上集群中任意一台服务器, 那么之前创建的会话依旧有效。

3. 数据节点(ZNode)
    + ZK有两种节点类型
       + 持久节点
       + 临时节点

    + ZK的数据模型就是一棵树, 树的节点就是ZNode, ZNode中可以保存信息。(数据内容和一系列属性信息)
      + 持久节点: 一旦这个ZNode被创建, 除非主动进行ZNode删除操作, 否则ZNode将一直保存在ZK上。
      + 临时节点: 它的生命周期和客户端会话绑定, 一旦客户端会话失效, 那么这个客户端创建的所有临时节点都会被删除。

    + ZK还允许用户为每个节点添加一个特殊属性, SEQUENTIAL。一旦节点被标记上这个属性, 那么在这个节点被创建时, ZK会自动在其节点名字后面加上一个整形数字, 这个整形数字是由父节点维护的自增数字。

4. 版本
  + 版本用来记录节点数据, 或者节点的子节点列表, 或者是权限信息的修改次数。每个ZNode都有3类版本信息。
    + version (当前数据节点数据内容的版本号)
    + cversion (当前数据节点子节点列表版本号)
    + aversion (当前数据节点ACL权限变更版本号)

  + 版本号的出现主要是解决ZNode并发更新问题, 实现CAS乐观锁

5. 事件监听器(watcher)
  + ZK集群允许用户在指定的节点上注册Watcher(事件监听器), 当数据节点变化的时候, ZK服务会把这个变化通知发送给感兴趣的客户端, 客户端收到这个变化通知, 可以在回到ZK中去取得详细信息。

6. ACL(权限控制)
  + ACL拥有五种权限类型
    + CREATE (创建子节点)
    + READ (读取节点数据及显示子节点列表)
    + WRITE (设置节点数据)
    + DELETE (删除子节点（仅下一级节点）)
    + ADMIN (设置节点访问控制列表权限)



#### ZooKeeper的架构图
ZK虽然是一个针对分布式系统的协调服务, 但它本身也是一个分布式程序。ZK遵循一个简单的客户端-服务器模型, 其中客户端是使用服务的节点, 而服务器则是提供服务的节点。ZK服务器的集合形成了一个ZK集合体。一个ZK客户端可连接到一个ZK服务器。每个ZK服务器可以同时处理大量客户端连接。每个客户端定期发送ping到它所连接的ZK服务器, 让服务器知道它处于活动和连接状态。被询问的ZK服务器通过ping确认进行响应, 表示服务器也处于活动状态。如果客户端在指定时间内没收到服务器的确认, 那么客户端会连接到集合体中的另一台服务器, 而且客户端会话会被透明的转移到新的ZK服务器上。

ZooKeeper 的客户端-服务器架构

![ZK架构图](https://github.com/basebase/img_server/blob/master/zk/zk04.png?raw=true) <br />


ZK有一个类似于文件系统的数据模型, 由znodes组成
![ZK架构图](https://github.com/basebase/img_server/blob/master/zk/zk05.png?raw=true)
znode层次结构被存储在ZK服务器内存中。这实现了对来自客户端的读取操作的快速响应。
每个ZK服务器还在磁盘上维护了一个事务日志, 记录所有的写请求。因为ZK服务器在返回一个成功的响应之前必须将事务同步到磁盘, 所以事务日志也是ZK中对性能最重要的组成部分。可以存储在znode中的数据默认最大为1MB, 因此, 即使ZK的层次结构看起来像文件系统, 也不应该将它用作一个通用的文件系统。相反, 应该只将它用作少量数据的存储机制, 以便为分布式应用程序提供可靠性, 可用性和协调。



#### ZooKeeper的命令使用

```shell

### 进入客户端
./zkCli.sh -server 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183

#### 此时, 已经进入ZK CLI了

### 当我们一开始不熟悉的时候, 我们一般使用-help或者简写-h来显示帮助, ZK也不例外
# 查看帮助信息
h

# 获取指定节点的状态信息
stat /zookeeper


### czxid 创建该节点的事物ID
### ctime 创建该节点的时间
### mZxid 更新该节点的事物ID
### mtime 更新该节点的时间
### pZxid 操作当前节点的子节点列表的事物ID(这种操作包含增加子节点，删除子节点)
### cversion 当前节点的子节点版本号
### dataVersion 当前节点的数据版本号
### aclVersion 当前节点的acl权限版本号
### ephemeralowner 当前节点的如果是临时节点，该属性是临时节点的事物ID
### dataLength 当前节点的d的数据长度
### numchildren 当前节点的子节点个数


# 创建节点, 节点不能以/结尾, 会出错(Path must not end with / character)
create /testdb
create /testdb/n1
create -e /testdb/n2 # 你会发现会话结束从新进入就消失了(-e 是临时节点)

# 是ls+stat命令的结合
ls2 /testdb

# 设置值到对应的节点
set /testdb/n1 "abcde"
# 当我们再次设置值, 会发现dataVersion更新了以及dataLength
set /testdb/n1 "gg1"

# 获取值
get /testdb/n1


## 删除节点(必须先删除子节点, 才能删除)
create /db2/nn1
create /db2/nn2
delete /db2
### Node not empty: /db2
delete /db2/nn1
delete /db2/nn2
delete /db2


### 退出客户端
quit

```
